{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SDKite Simple framework for building SDKs and API clients Installation Install SDKite with pip: $ python -m pip install sdkite Python version support As a general rule, all Python versions that are both released and still officially supported are supported by sdkite and tested against. If you have other use cases or find issues with some Python versions, feel free to open a ticket ! Status of the project SDKite is currently in pre-alpha : the API may change in future releases. Changes are well detailed in the changelog , and the version numbering follow semver . Note This documentation is also a work-in-progress.","title":"Home"},{"location":"#sdkite","text":"Simple framework for building SDKs and API clients","title":"SDKite"},{"location":"#installation","text":"Install SDKite with pip: $ python -m pip install sdkite","title":"Installation"},{"location":"#python-version-support","text":"As a general rule, all Python versions that are both released and still officially supported are supported by sdkite and tested against. If you have other use cases or find issues with some Python versions, feel free to open a ticket !","title":"Python version support"},{"location":"#status-of-the-project","text":"SDKite is currently in pre-alpha : the API may change in future releases. Changes are well detailed in the changelog , and the version numbering follow semver . Note This documentation is also a work-in-progress.","title":"Status of the project"},{"location":"http_auth/","text":"HTTP authentication Helpers are provided to manage the common schemes of HTTP authentications. They take the HTTPAdapterSpec instance as first argument. Internally, they register an interceptor that will add the required Authorization header. Basic authentication The BasicAuth helper takes to optional arguments username and password : >>> from sdkite.http import BasicAuth, HTTPAdapterSpec >>> class RootClient(Client): ... _http = HTTPAdapterSpec(url=\"https://api.example.com/\") ... _auth = BasicAuth(_http, \"Alice\", \"W0nderl@nd\") ... ... def whoami(self): ... return self._http.get('whoami').data_str >>> RootClient().whoami() 'Welcome Alice!' The values can also be set at runtime by modifying the corresponding attributes of the instance: >>> class RootClient(Client): ... _http = HTTPAdapterSpec(url=\"https://api.example.com/\") ... _auth = BasicAuth(_http) ... ... def __init__(self, username, password): ... super().__init__() ... self._auth.username = username ... self._auth.password = password ... ... def whoami(self): ... return self._http.get('whoami').data_str >>> RootClient('Alice', 'W0nderl@nd').whoami() 'Welcome Alice!' Removing authentication If you have defined some authentication on a client, you can remove it on sub-clients by using NoAuth : >>> from sdkite.http import NoAuth >>> class ChildClient(Client): ... _http = HTTPAdapterSpec() ... _auth = NoAuth(_http) ... ... def example(self): ... return self._http.get('noauth').data_str >>> class RootClient(Client): ... _http = HTTPAdapterSpec(url=\"https://api.example.com/\") ... _auth = BasicAuth(_http, \"user\", \"password\") ... child: ChildClient >>> RootClient().child.example() # will not add basic auth 'The /noauth endpoint has been called without auth' Note The name of the class attribute ( _auth in the example) must be the same in both clients, otherwise the authentication is not overridden.","title":"Authentication"},{"location":"http_auth/#http-authentication","text":"Helpers are provided to manage the common schemes of HTTP authentications. They take the HTTPAdapterSpec instance as first argument. Internally, they register an interceptor that will add the required Authorization header.","title":"HTTP authentication"},{"location":"http_auth/#basic-authentication","text":"The BasicAuth helper takes to optional arguments username and password : >>> from sdkite.http import BasicAuth, HTTPAdapterSpec >>> class RootClient(Client): ... _http = HTTPAdapterSpec(url=\"https://api.example.com/\") ... _auth = BasicAuth(_http, \"Alice\", \"W0nderl@nd\") ... ... def whoami(self): ... return self._http.get('whoami').data_str >>> RootClient().whoami() 'Welcome Alice!' The values can also be set at runtime by modifying the corresponding attributes of the instance: >>> class RootClient(Client): ... _http = HTTPAdapterSpec(url=\"https://api.example.com/\") ... _auth = BasicAuth(_http) ... ... def __init__(self, username, password): ... super().__init__() ... self._auth.username = username ... self._auth.password = password ... ... def whoami(self): ... return self._http.get('whoami').data_str >>> RootClient('Alice', 'W0nderl@nd').whoami() 'Welcome Alice!'","title":"Basic authentication"},{"location":"http_auth/#removing-authentication","text":"If you have defined some authentication on a client, you can remove it on sub-clients by using NoAuth : >>> from sdkite.http import NoAuth >>> class ChildClient(Client): ... _http = HTTPAdapterSpec() ... _auth = NoAuth(_http) ... ... def example(self): ... return self._http.get('noauth').data_str >>> class RootClient(Client): ... _http = HTTPAdapterSpec(url=\"https://api.example.com/\") ... _auth = BasicAuth(_http, \"user\", \"password\") ... child: ChildClient >>> RootClient().child.example() # will not add basic auth 'The /noauth endpoint has been called without auth' Note The name of the class attribute ( _auth in the example) must be the same in both clients, otherwise the authentication is not overridden.","title":"Removing authentication"},{"location":"http_engine/","text":"HTTP engine The HTTP engine is the responsible for taking an HTTPRequest and returning the response as an HTTPResponse object. The following engines are provided: HTTPEngineRequests based on the requests ; this engine is chosen by default HTTPEngineReplay to be able to record and replay requests ( more info ) Changing the engine The method HTTPAdapterSpec.set_engine can be used to switch to an other engine: >>> from sdkite import Client >>> from sdkite.http import HTTPAdapterSpec >>> class ExampleClient(Client): ... _http = HTTPAdapterSpec(\"https://api.example.com/\") ... # directly when defining the Client class ... _http.set_engine(ExampleEngine) # or afterwards >>> ExampleClient._http.set_engine(ExampleEngine) # but not once the client is instantiated! >>> client = ExampleClient() >>> client._http.set_engine(ExampleEngine) Traceback (most recent call last): ... AttributeError: 'HTTPAdapter' object has no attribute 'set_engine' Warning The engine must be set on the HTTPAdapterSpec of the root client, otherwise it is not used. Passing arguments to the engine Arguments can be passed to the engine by providing them directly to set_engine . >>> class ExampleClient(Client): ... _http = HTTPAdapterSpec(\"https://api.example.com/\") ... _http.set_engine(ExampleEngine, 'pos0', 'pos1', kw0=13, kw1=37)","title":"Engine"},{"location":"http_engine/#http-engine","text":"The HTTP engine is the responsible for taking an HTTPRequest and returning the response as an HTTPResponse object. The following engines are provided: HTTPEngineRequests based on the requests ; this engine is chosen by default HTTPEngineReplay to be able to record and replay requests ( more info )","title":"HTTP engine"},{"location":"http_engine/#changing-the-engine","text":"The method HTTPAdapterSpec.set_engine can be used to switch to an other engine: >>> from sdkite import Client >>> from sdkite.http import HTTPAdapterSpec >>> class ExampleClient(Client): ... _http = HTTPAdapterSpec(\"https://api.example.com/\") ... # directly when defining the Client class ... _http.set_engine(ExampleEngine) # or afterwards >>> ExampleClient._http.set_engine(ExampleEngine) # but not once the client is instantiated! >>> client = ExampleClient() >>> client._http.set_engine(ExampleEngine) Traceback (most recent call last): ... AttributeError: 'HTTPAdapter' object has no attribute 'set_engine' Warning The engine must be set on the HTTPAdapterSpec of the root client, otherwise it is not used.","title":"Changing the engine"},{"location":"http_engine/#passing-arguments-to-the-engine","text":"Arguments can be passed to the engine by providing them directly to set_engine . >>> class ExampleClient(Client): ... _http = HTTPAdapterSpec(\"https://api.example.com/\") ... _http.set_engine(ExampleEngine, 'pos0', 'pos1', kw0=13, kw1=37)","title":"Passing arguments to the engine"},{"location":"http_replay/","text":"HTTP replay engine Record and replay the HTTP interactions by setting the HTTP engine to HTTPEngineReplay . This is useful for fast and deterministic tests. Inspired by VCR for Ruby and the similar projects for Python. Warning This feature is experimental, and the format in which records are saved on disk is subject to change in future versions. Engine parameters paths An iterable of Path s to specify the record stores. If a request matches a record from several paths, the last one will be used. recording (optional) A bool telling wether real HTTP requests will be send (and saved) instead of loaded from an existing record. Otherwise, no HTTP requests will be sent at all, and exceptions will be raised if no matching requests are found in the record store. replay_request_modifier (optional) Allow to modify the request before looking it up in the record store. replay_response_modifier (optional) Allow to modify the response after retrieving it from the record store. recording_request_modifier (optional) Allow to modify the request before sending the HTTP interaction for real. Only used in recording mode. Note that the argument has not been modified by replay_request_modifier . recording_response_modifier (optional) Allow to modify the response received from a real HTTP interaction before saving it to the record store. Only used in recording mode. Note that after being saved, the returned value will then pass through replay_response_modifier before being sent to the caller. recording_compute_basename (optional) Allow to compute the base name of the record file to be saved. A .json extension will be appended to the returned value. Only used in recording mode. Example >>> from sdkite import Client >>> from sdkite.http import HTTPAdapterSpec >>> from sdkite.http.engine_replay import HTTPEngineReplay >>> class TableTennis(Client): ... _http = HTTPAdapterSpec(\"https://api.example.com/\") ... ... def ping(self): ... return self._http.get(\"ping\").data_str >>> TableTennis._http.set_engine(HTTPEngineReplay, [Path(\"replay\")]) >>> table_tennis = TableTennis() >>> table_tennis.ping() 'pong'","title":"Record & replay"},{"location":"http_replay/#http-replay-engine","text":"Record and replay the HTTP interactions by setting the HTTP engine to HTTPEngineReplay . This is useful for fast and deterministic tests. Inspired by VCR for Ruby and the similar projects for Python. Warning This feature is experimental, and the format in which records are saved on disk is subject to change in future versions.","title":"HTTP replay engine"},{"location":"http_replay/#engine-parameters","text":"paths An iterable of Path s to specify the record stores. If a request matches a record from several paths, the last one will be used. recording (optional) A bool telling wether real HTTP requests will be send (and saved) instead of loaded from an existing record. Otherwise, no HTTP requests will be sent at all, and exceptions will be raised if no matching requests are found in the record store. replay_request_modifier (optional) Allow to modify the request before looking it up in the record store. replay_response_modifier (optional) Allow to modify the response after retrieving it from the record store. recording_request_modifier (optional) Allow to modify the request before sending the HTTP interaction for real. Only used in recording mode. Note that the argument has not been modified by replay_request_modifier . recording_response_modifier (optional) Allow to modify the response received from a real HTTP interaction before saving it to the record store. Only used in recording mode. Note that after being saved, the returned value will then pass through replay_response_modifier before being sent to the caller. recording_compute_basename (optional) Allow to compute the base name of the record file to be saved. A .json extension will be appended to the returned value. Only used in recording mode.","title":"Engine parameters"},{"location":"http_replay/#example","text":">>> from sdkite import Client >>> from sdkite.http import HTTPAdapterSpec >>> from sdkite.http.engine_replay import HTTPEngineReplay >>> class TableTennis(Client): ... _http = HTTPAdapterSpec(\"https://api.example.com/\") ... ... def ping(self): ... return self._http.get(\"ping\").data_str >>> TableTennis._http.set_engine(HTTPEngineReplay, [Path(\"replay\")]) >>> table_tennis = TableTennis() >>> table_tennis.ping() 'pong'","title":"Example"},{"location":"http_request/","text":"HTTP Request HTTP method The first parameter of the request method of an HTTP adapter allows to specify the HTTP method to be used. The HTTP adapter provides syntactic sugar for regular HTTP methods: get , options , head , post , put , patch , delete . URL The URL will be computed from: The url attribute of the HTTPAdapterSpec of each client The url argument passed to the request method (or get , post , etc.) The rules used for combining URLs are quite flexible, and allow for the most frequent use cases: Appending to the URL (a / separator will be used) Keeping only the base URL by using an absolute path (starting with / ) Replacing the URL entirely by specifying an other URL Body The body and body_encoding decide the data that will be sent in the body of the request. Here are the possible values for body_encoding : HTTPBodyEncoding.AUTO Some heuristics are used to determine which encoding to use. HTTPBodyEncoding.NONE Only basic types such as bytes and str are allowed, and will be passed transparently. HTTPBodyEncoding.JSON Data will be JSON-encoded. HTTPBodyEncoding.URLENCODE Only works for dict types; keys and values will be urlencoded like a query string. HTTPBodyEncoding.MULTIPART Only works for dict types; all values are encoded as if they were file data. Headers The headers will be computed from: The headers attribute of the HTTPAdapterSpec of each client The headers argument passed to the request method (or get , post , etc.) The later values override the former ones, in a case-insensitive manner. Note Depending on the body_encoding value, a content-type header may be automatically added. Stream mode To ask the server to stream the response, set the stream_response parameter to True . It is then recommended to use the data_stream attribute of the response object .","title":"Request"},{"location":"http_request/#http-request","text":"","title":"HTTP Request"},{"location":"http_request/#http-method","text":"The first parameter of the request method of an HTTP adapter allows to specify the HTTP method to be used. The HTTP adapter provides syntactic sugar for regular HTTP methods: get , options , head , post , put , patch , delete .","title":"HTTP method"},{"location":"http_request/#url","text":"The URL will be computed from: The url attribute of the HTTPAdapterSpec of each client The url argument passed to the request method (or get , post , etc.) The rules used for combining URLs are quite flexible, and allow for the most frequent use cases: Appending to the URL (a / separator will be used) Keeping only the base URL by using an absolute path (starting with / ) Replacing the URL entirely by specifying an other URL","title":"URL"},{"location":"http_request/#body","text":"The body and body_encoding decide the data that will be sent in the body of the request. Here are the possible values for body_encoding : HTTPBodyEncoding.AUTO Some heuristics are used to determine which encoding to use. HTTPBodyEncoding.NONE Only basic types such as bytes and str are allowed, and will be passed transparently. HTTPBodyEncoding.JSON Data will be JSON-encoded. HTTPBodyEncoding.URLENCODE Only works for dict types; keys and values will be urlencoded like a query string. HTTPBodyEncoding.MULTIPART Only works for dict types; all values are encoded as if they were file data.","title":"Body"},{"location":"http_request/#headers","text":"The headers will be computed from: The headers attribute of the HTTPAdapterSpec of each client The headers argument passed to the request method (or get , post , etc.) The later values override the former ones, in a case-insensitive manner. Note Depending on the body_encoding value, a content-type header may be automatically added.","title":"Headers"},{"location":"http_request/#stream-mode","text":"To ask the server to stream the response, set the stream_response parameter to True . It is then recommended to use the data_stream attribute of the response object .","title":"Stream mode"},{"location":"http_response/","text":"HTTP Response The following attributes of the HTTP response can be used: status_code The HTTP status code (e.g. 401 ) reason The HTTP reason phrase (e.g. \"Unauthorized\" ) headers The HTTP headers as an HTTPHeaderDict instance data_bytes The body of the response as bytes data_stream The body of the response as an Iterator[bytes] ; useful for streaming data_str The body of the response as a str data_json The body of the response JSON-decoded raw The response object coming from the adapter (e.g. requests.Response )","title":"Response"},{"location":"http_response/#http-response","text":"The following attributes of the HTTP response can be used: status_code The HTTP status code (e.g. 401 ) reason The HTTP reason phrase (e.g. \"Unauthorized\" ) headers The HTTP headers as an HTTPHeaderDict instance data_bytes The body of the response as bytes data_stream The body of the response as an Iterator[bytes] ; useful for streaming data_str The body of the response as a str data_json The body of the response JSON-decoded raw The response object coming from the adapter (e.g. requests.Response )","title":"HTTP Response"},{"location":"pagination/","text":"Pagination A paginated decorator is provided to help when the same function should be called several times, with each call returning a partial set of the data. Note This works for any functions and methods, not just for methods of Client subclasses. Overview Your friend Ranis is a well-known wizard who has several spells for sale. She gives you a function that returns the spells she's selling, given a budget. However, at most 3 items are returned at a time, so you have to call it multiple times to retrieve the list of all her spells. By page index Given the following list_spells function: >>> list_spells(max_price=50, page=0) ['Crushing Burden Touch', 'Great Burden of Sin', 'Heavy Burden'] >>> list_spells(max_price=50, page=1) ['Strong Feather', \"Tinur's Hoptoad\", \"Ulms's Juicedaw's Feather\"] >>> list_spells(max_price=50, page=2) ['Far Silence', 'Soul Trap'] >>> list_spells(max_price=50, page=3) [] Use pagination.page : >>> from sdkite import paginated >>> @paginated() ... def get_spells1(pagination, max_price): ... return list_spells(max_price=max_price, page=pagination.page) >>> result = get_spells1(50) # the only parameter of get_spells1 is max_price >>> isinstance(result, Iterator) True >>> for spell in result: ... print(repr(spell)) 'Crushing Burden Touch' 'Great Burden of Sin' 'Heavy Burden' 'Strong Feather' \"Tinur's Hoptoad\" \"Ulms's Juicedaw's Feather\" 'Far Silence' 'Soul Trap' By the position of the first item Given the following list_spells function: >>> list_spells(max_price=50, offset=0) ['Crushing Burden Touch', 'Great Burden of Sin', 'Heavy Burden'] >>> list_spells(max_price=50, offset=1) # overlap with last call ['Great Burden of Sin', 'Heavy Burden', 'Strong Feather'] Use pagination.offset : >>> @paginated() ... def get_spells2(pagination, max_price): ... return list_spells(max_price=max_price, offset=pagination.offset) >>> for spell in get_spells2(50): ... print(repr(spell)) 'Crushing Burden Touch' 'Great Burden of Sin' 'Heavy Burden' 'Strong Feather' \"Tinur's Hoptoad\" \"Ulms's Juicedaw's Feather\" 'Far Silence' 'Soul Trap' By the reference to the next page To avoid having invalid results due to items changing between two calls, some APIs gives you a reference to the next page of your query. Given the following list_spells_with_ref function: >>> list_spells_with_ref(max_price=50) (['Crushing Burden Touch', 'Great Burden of Sin', 'Heavy Burden'], '57656c636') >>> list_spells_with_ref(cursor=\"57656c636\") (['Strong Feather', \"Tinur's Hoptoad\", \"Ulms's Juicedaw's Feather\"], 'f6d652074') >>> list_spells_with_ref(cursor=\"f6d652074\") (['Far Silence', 'Soul Trap'], '6f2042616') >>> list_spells_with_ref(cursor=\"6f2042616\") ([], 'c6d6f7261') Use pagination.context to store this reference: >>> @paginated() ... def get_spells3(pagination, max_price): ... if pagination.context is None: ... data, next_cursor = list_spells_with_ref(max_price=max_price) ... else: ... data, next_cursor = list_spells_with_ref(cursor=pagination.context) ... pagination.context = next_cursor ... return data >>> for spell in get_spells3(50): ... print(repr(spell)) 'Crushing Burden Touch' 'Great Burden of Sin' 'Heavy Burden' 'Strong Feather' \"Tinur's Hoptoad\" \"Ulms's Juicedaw's Feather\" 'Far Silence' 'Soul Trap' Usage Decorated function The decorated function must take pagination as its first parameter, which will be inserted by the decorator with a Pagination instance. Note For methods of a class, the pagination parameter must come just after self . An iterable must be returned by the decorated function. Items of this iterable will be consumed one by one only when needed. Note The returned iterable can be of any size, which can vary at each call. However, if the iterable is empty, it will be assumed that the current page is the last, unless stop_when_empty=False was passed to paginated . The Pagination object The following attributes of pagination are available: page (read-only) The index of the current page. offset (read-only) The index of the next item. context Any arbitrary data that can be set on the pagination variable to persist from one call of the decorated function to the other. finished (read-only) A boolean indicating if a new page is expected to come after the current one. finish() Call this method to indicate that the current page is the last one. The paginated decorator The following parameters can be passed to paginated : page , offset , context The initial values of the corresponding attributes of the Pagination object passed to the decorated function (default to 0 , 0 and None respectively). stop_when_empty Whether a next page will be fetched if no items have been generated on the current page (defaults to True ). If False , the finish method of the Pagination object must me called to tell when to stop.","title":"Pagination"},{"location":"pagination/#pagination","text":"A paginated decorator is provided to help when the same function should be called several times, with each call returning a partial set of the data. Note This works for any functions and methods, not just for methods of Client subclasses.","title":"Pagination"},{"location":"pagination/#overview","text":"Your friend Ranis is a well-known wizard who has several spells for sale. She gives you a function that returns the spells she's selling, given a budget. However, at most 3 items are returned at a time, so you have to call it multiple times to retrieve the list of all her spells.","title":"Overview"},{"location":"pagination/#by-page-index","text":"Given the following list_spells function: >>> list_spells(max_price=50, page=0) ['Crushing Burden Touch', 'Great Burden of Sin', 'Heavy Burden'] >>> list_spells(max_price=50, page=1) ['Strong Feather', \"Tinur's Hoptoad\", \"Ulms's Juicedaw's Feather\"] >>> list_spells(max_price=50, page=2) ['Far Silence', 'Soul Trap'] >>> list_spells(max_price=50, page=3) [] Use pagination.page : >>> from sdkite import paginated >>> @paginated() ... def get_spells1(pagination, max_price): ... return list_spells(max_price=max_price, page=pagination.page) >>> result = get_spells1(50) # the only parameter of get_spells1 is max_price >>> isinstance(result, Iterator) True >>> for spell in result: ... print(repr(spell)) 'Crushing Burden Touch' 'Great Burden of Sin' 'Heavy Burden' 'Strong Feather' \"Tinur's Hoptoad\" \"Ulms's Juicedaw's Feather\" 'Far Silence' 'Soul Trap'","title":"By page index"},{"location":"pagination/#by-the-position-of-the-first-item","text":"Given the following list_spells function: >>> list_spells(max_price=50, offset=0) ['Crushing Burden Touch', 'Great Burden of Sin', 'Heavy Burden'] >>> list_spells(max_price=50, offset=1) # overlap with last call ['Great Burden of Sin', 'Heavy Burden', 'Strong Feather'] Use pagination.offset : >>> @paginated() ... def get_spells2(pagination, max_price): ... return list_spells(max_price=max_price, offset=pagination.offset) >>> for spell in get_spells2(50): ... print(repr(spell)) 'Crushing Burden Touch' 'Great Burden of Sin' 'Heavy Burden' 'Strong Feather' \"Tinur's Hoptoad\" \"Ulms's Juicedaw's Feather\" 'Far Silence' 'Soul Trap'","title":"By the position of the first item"},{"location":"pagination/#by-the-reference-to-the-next-page","text":"To avoid having invalid results due to items changing between two calls, some APIs gives you a reference to the next page of your query. Given the following list_spells_with_ref function: >>> list_spells_with_ref(max_price=50) (['Crushing Burden Touch', 'Great Burden of Sin', 'Heavy Burden'], '57656c636') >>> list_spells_with_ref(cursor=\"57656c636\") (['Strong Feather', \"Tinur's Hoptoad\", \"Ulms's Juicedaw's Feather\"], 'f6d652074') >>> list_spells_with_ref(cursor=\"f6d652074\") (['Far Silence', 'Soul Trap'], '6f2042616') >>> list_spells_with_ref(cursor=\"6f2042616\") ([], 'c6d6f7261') Use pagination.context to store this reference: >>> @paginated() ... def get_spells3(pagination, max_price): ... if pagination.context is None: ... data, next_cursor = list_spells_with_ref(max_price=max_price) ... else: ... data, next_cursor = list_spells_with_ref(cursor=pagination.context) ... pagination.context = next_cursor ... return data >>> for spell in get_spells3(50): ... print(repr(spell)) 'Crushing Burden Touch' 'Great Burden of Sin' 'Heavy Burden' 'Strong Feather' \"Tinur's Hoptoad\" \"Ulms's Juicedaw's Feather\" 'Far Silence' 'Soul Trap'","title":"By the reference to the next page"},{"location":"pagination/#usage","text":"","title":"Usage"},{"location":"pagination/#decorated-function","text":"The decorated function must take pagination as its first parameter, which will be inserted by the decorator with a Pagination instance. Note For methods of a class, the pagination parameter must come just after self . An iterable must be returned by the decorated function. Items of this iterable will be consumed one by one only when needed. Note The returned iterable can be of any size, which can vary at each call. However, if the iterable is empty, it will be assumed that the current page is the last, unless stop_when_empty=False was passed to paginated .","title":"Decorated function"},{"location":"pagination/#the-pagination-object","text":"The following attributes of pagination are available: page (read-only) The index of the current page. offset (read-only) The index of the next item. context Any arbitrary data that can be set on the pagination variable to persist from one call of the decorated function to the other. finished (read-only) A boolean indicating if a new page is expected to come after the current one. finish() Call this method to indicate that the current page is the last one.","title":"The Pagination object"},{"location":"pagination/#the-paginated-decorator","text":"The following parameters can be passed to paginated : page , offset , context The initial values of the corresponding attributes of the Pagination object passed to the decorated function (default to 0 , 0 and None respectively). stop_when_empty Whether a next page will be fetched if no items have been generated on the current page (defaults to True ). If False , the finish method of the Pagination object must me called to tell when to stop.","title":"The paginated decorator"},{"location":"quickstart/","text":"Quickstart Let's write a SDK for an HTTP API that retrieves data from an imaginary world. Simple example Let's start with an example: >>> from sdkite import Client >>> from sdkite.http import HTTPAdapterSpec >>> class World(Client): ... _http = HTTPAdapterSpec(\"https://api.example.com/world\") ... ... def npc_interact(self, name): ... return self._http.get(f\"npc/interact?name={name}\").data_str ... ... def npc_search(self, **kwargs): ... return self._http.post(f\"npc/search\", body=kwargs).data_json >>> world = World() >>> world.npc_interact(\"ranis\") 'Have you found the Telvanni spy?' >>> world.npc_search(city=\"Balmora\", faction=\"Mage\", min_level=8) ['marayn', 'masalinie', 'ranis'] Notice thee following: Our root class World is a subclass of Client We have defined _http as a class variable The URLs parts https://api.example.com/world and npc/info?name={name} are combined to create the real URl that has been called: https://api.example.com/world/npc/info?name=ranis The body parameter is converted automatically to be used as the request body, but a specific encoding can be specified Note The _http naming is arbitrary; we suggest using a leading underscore _ as a convention to indicate to the consumer of the World class that the attribute should not be used directly. More complex example >>> from sdkite.http import BasicAuth >>> class WorldNpc(Client): ... _http = HTTPAdapterSpec(\"npc\") ... ... def interact(self, name): ... return self._http.get(f\"interact?name={name}\").data_str ... ... def search(self, **kwargs): ... return self._http.post(f\"search\", body=kwargs).data_json ... >>> class WorldBook(Client): ... _http = HTTPAdapterSpec(\"book\") ... ... def download(self, book_id, path): ... response = self._http.get(f\"content?id={book_id}\", stream_response=True) ... with path.open(\"wb\") as fp: ... for data in response.data_stream: ... fp.write(data) >>> class World(Client): ... _http = HTTPAdapterSpec(\"https://api.example.com/world\") ... _auth = BasicAuth(_http) ... ... npc: WorldNpc ... book: WorldBook ... ... def __init__(self, username, password): ... super().__init__() ... self._auth.username = username ... self._auth.password = password >>> world = World(\"Nerevarine\", \"Incarnate\") >>> world.npc.interact(\"ranis\") 'Have you found the Telvanni spy?' >>> path = Path(\"book.txt\") >>> world.book.download(\"bk_words_of_the_wind\", path) >>> path.read_text()[:18] 'Words of the Wind\\n' Sub-clients are used to group endpoints together, and are automatically instantiated Basic authentication is set up on the root client, to be used on all sub-clients Response streaming is used to store the content of a book into a file","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Let's write a SDK for an HTTP API that retrieves data from an imaginary world.","title":"Quickstart"},{"location":"quickstart/#simple-example","text":"Let's start with an example: >>> from sdkite import Client >>> from sdkite.http import HTTPAdapterSpec >>> class World(Client): ... _http = HTTPAdapterSpec(\"https://api.example.com/world\") ... ... def npc_interact(self, name): ... return self._http.get(f\"npc/interact?name={name}\").data_str ... ... def npc_search(self, **kwargs): ... return self._http.post(f\"npc/search\", body=kwargs).data_json >>> world = World() >>> world.npc_interact(\"ranis\") 'Have you found the Telvanni spy?' >>> world.npc_search(city=\"Balmora\", faction=\"Mage\", min_level=8) ['marayn', 'masalinie', 'ranis'] Notice thee following: Our root class World is a subclass of Client We have defined _http as a class variable The URLs parts https://api.example.com/world and npc/info?name={name} are combined to create the real URl that has been called: https://api.example.com/world/npc/info?name=ranis The body parameter is converted automatically to be used as the request body, but a specific encoding can be specified Note The _http naming is arbitrary; we suggest using a leading underscore _ as a convention to indicate to the consumer of the World class that the attribute should not be used directly.","title":"Simple example"},{"location":"quickstart/#more-complex-example","text":">>> from sdkite.http import BasicAuth >>> class WorldNpc(Client): ... _http = HTTPAdapterSpec(\"npc\") ... ... def interact(self, name): ... return self._http.get(f\"interact?name={name}\").data_str ... ... def search(self, **kwargs): ... return self._http.post(f\"search\", body=kwargs).data_json ... >>> class WorldBook(Client): ... _http = HTTPAdapterSpec(\"book\") ... ... def download(self, book_id, path): ... response = self._http.get(f\"content?id={book_id}\", stream_response=True) ... with path.open(\"wb\") as fp: ... for data in response.data_stream: ... fp.write(data) >>> class World(Client): ... _http = HTTPAdapterSpec(\"https://api.example.com/world\") ... _auth = BasicAuth(_http) ... ... npc: WorldNpc ... book: WorldBook ... ... def __init__(self, username, password): ... super().__init__() ... self._auth.username = username ... self._auth.password = password >>> world = World(\"Nerevarine\", \"Incarnate\") >>> world.npc.interact(\"ranis\") 'Have you found the Telvanni spy?' >>> path = Path(\"book.txt\") >>> world.book.download(\"bk_words_of_the_wind\", path) >>> path.read_text()[:18] 'Words of the Wind\\n' Sub-clients are used to group endpoints together, and are automatically instantiated Basic authentication is set up on the root client, to be used on all sub-clients Response streaming is used to store the content of a book into a file","title":"More complex example"},{"location":"typing/","text":"Typing SDKite commes natively with type hints, which are checked by mypy . The benefits are twofold: Improve the correctness of the code of the library itself; Allow users of the library to benefit from well-defined type hints on the public API. As a rule of thumbs, we follow Postel's law by being as vague as possible for the arguments of functions, and as precise as possible for the returned values.","title":"Typing"},{"location":"typing/#typing","text":"SDKite commes natively with type hints, which are checked by mypy . The benefits are twofold: Improve the correctness of the code of the library itself; Allow users of the library to benefit from well-defined type hints on the public API. As a rule of thumbs, we follow Postel's law by being as vague as possible for the arguments of functions, and as precise as possible for the returned values.","title":"Typing"}]}